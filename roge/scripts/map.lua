unit = require "unit"require "utils"event     = require "events"local function print(...)    oldprint("map", ...)endlocal mover = {}unit.player.mover = movermover.filler = unit.playerCell = {x =0, y = 0,  color = "black", f = function() end, type = "cell"}Cell.__index = Cell-- Cell.__index = function() return {} endCell.create = function (x, y, filler, color, bag)    local t = {}    t.x = x    t.y = y    t.filler = filler        t.color = color or "black"        t.bag = bag     -- print(" cell createcell")     setmetatable(t, Cell)    return tendCell.getVisual = function (self)    -- screen:print2(self) local empty = {}  -- print("getvisual")  -- print(tostring( (self.filler or {}).symbol or " "))  -- screen:print2 (self.filler)  local emptyCell = " "  if self.visible then emptyCell = "." end   local symbol = " " -- print("symbol"..symbol) local bkColor = self.color -- print("bkColor") -- print(bkColor) local color = "white" if self.visible then    symbol = ((self.filler or empty).symbol or emptyCell)    color = (self.filler or empty).color or "grey"    if symbol == emptyCell and self.bag and #self.bag > 0 then        symbol = '$'        color = "yellow"    end elseif self.known then     color = "grey"     symbol = ((self.filler or empty).symbol or emptyCell) end -- print(color)     return { ["symbol"] = symbol,            ["bkColor"] = bkColor,             ["color"]   = color}endfunction Cell:setFiller ( filler)    if not self.filler then        filler.mover.cell.filler = nil        self.filler = filler        if (filler.mover)  then             -- screen:print("cell"..self.x..":"..self.y)            filler.mover.cell = self             -- screen:print("moverCell"..Map.mover.cell.x..":"..Map.mover.cell.y)        else            -- screen:print("cell false"..self.x..":"..self.y)        end        return true    else    -- screen:print("cell inter"..self.x..":"..self.y)        filler:interaction(self.filler)        return false    end     endlocal Map  = {cells = {}, width = 0, height = 0, ["mover"] = mover}function Map:createCell(x, y, filler, color, bag)    -- print(x..":"..y)    if(self.cells[x] == nil) then self.cells[x] = {} end    local cell              = Cell.create(x, y, filler, color, bag)    self.cells[x][y]        = cell    if filler and filler.mover then        filler.mover.cell   = cell    endendfunction Map:getFreeCell()    local cells = self.cells    for i = 1, self.width do        for j = 1, self.height do            if(cells[i][j].filler == nil) then                return cells[i][j]            end        end    endendfunction Map:getCell(x,y)    return self.cells[x][y]endfunction Map:createMap(lx, ly, bkColor)-- print("createmap")    self.width = lx    self.height = ly    for i = 1, lx do        for j = 1, ly do            local cell = {}            local filler = nil              if Random:random(10) == 1 then filler = unit.createFiller("#", "white", "whall") end                self:createCell(i, j, filler,bkColor)        end    end    local cell = self:getFreeCell()    cell.filler = unit.player    mover.cell = cell    endfunction Map:createMapFromTable(t)    self.width = t.width    self.height = t.height    for i = 1, self.width do        for j = 1, self.height do            local pos = (i - 1)*self.height + j            local ch = t.map:sub(pos, pos)            local filler = nil            local bag    = nil            if ch == ' ' then                            elseif ch == '#' then                filler = unit.createFiller("#", "white", "whall")            elseif ch == '@' then                filler = unit.player            else                if t[ch] == "bag" then                    bag = {createItem(t.items[1], t.items[1], 1, "item")}                elseif t[ch] == "enemy" then                    filler = unit.createFiller(ch, "red", "enemy")                end            end            self:createCell(i, j, filler, t.bkColor, bag)        end    endendfunction mover:Move(direction)    local x = self.cell.x    local y = self.cell.y    local x0 = x    local y0 = y    if direction == direct.up or direction == direct.w then        x = x - 1    elseif direction == direct.down or direction == direct.s then        x = x + 1    elseif direction == direct.right or direction == direct.d then        y = y + 1    elseif direction == direct.left or direction == direct.a then        y = y - 1    elseif direction == direct.e then        y = y + 1        x = x - 1    elseif direction == direct.q then        x = x - 1        y = y - 1    elseif direction == direct.z then        y = y - 1        x = x + 1    elseif direction == direct.x then        x = x + 1        y = y + 1    end    if      x < 1           then x = 1     elseif  x > Map.width   then x = Map.width end    if      y < 1 then y = 1     elseif  y > Map.height  then y = Map.height end     self:blinkTo(x, y)endfunction mover:blinkTo(x, y)    local cell = self.cell or {}    local x0 = self.cell.x    local y0 = self.cell.y        local filler = self.filler    cell = Map:getCell(x,y)    if cell:setFiller(filler) then         local distance = math.sqrt((x-x0)*(x-x0) + (y-y0)*(y-y0))        print("distance", distance)        event.send(mover.filler, "move", distance)    endendfunction Map.getDistance(cell1, cell2)    return math.sqrt((cell1.x-cell2.x)*(cell1.x-cell2.x) + (cell1.y-cell2.y)*(cell1.y-cell2.y) )endfunction Map:getCells(cell1, cell2)    local cells = {}    local x1 = cell1.x    local y1 = cell1.y    local x2 = cell2.x    local y2 = cell2.y    table.insert(cells, cell1)            -- screen:print(k.."dd"..h)    -- screen:print(cell1.x..":"..cell1.y.."]:["..cell2.x..":"..cell2.y.."]:".."cn"..x1..":"..x2)         if math.abs(cell2.x - cell1.x) > math.abs(cell2.y - cell1.y) then            local k = (y1 - y2)/(x1 - x2)            local h = y2 - k*x2            if x1 < x2 then                 for i = x1, x2 - 1 do                    local y = math.floor(k*i + h)                    -- screen:print(x)                    -- screen:print2( self.cells[x] )                    table.insert(cells, self.cells[math.floor(i)][y])                end            else                for i = x1, x2 + 1, -1 do                    local y = math.floor(k*i + h)                    -- screen:print(x1..":"..x2..":"..i..":"..y)                    table.insert(cells, self.cells[math.floor(i)][y])                end            end        else            local k = (x1 - x2)/(y1 - y2)            local h = x2 - k*y2            -- screen:print(cell1.x.." "..cell1.y.." "..cell2.x.." "..cell2.y.." "..k.." "..h)            if y1 < y2 then                for i = y1, y2 - 1  do                    local x = math.floor(k * i + h)                     -- screen:print2( self.cells[x] )                     -- screen:print(x..' '..i)                    table.insert(cells, self.cells[x][math.floor(i)])                end            else                for i = y1, y2 + 1, -1  do                    local x = math.floor(k * i + h)                    table.insert(cells, self.cells[x][math.floor(i)])                end            end        end        return cellsendfunction Map:getVisibility(cell1, cell2)        local cells = self:getCells(cell1, cell2)        -- screen:print(cell1.x..":"..cell1.y.."]:["..cell2.x..":"..cell2.y.."]:".."cn"..tostring(#cells))         local visible = true        local visCount = 0        local invisCount = 0        foreach(cells, function(v, k)                         if (v.filler or empty).type == "whall" then                         -- screen:print(cell1.x..":"..cell1.y.."]:["..cell2.x..":"..cell2.y.."]:".."invisible")                         visible = false                         end                       end)    -- screen:print(cell1.x..":"..cell1.y.."]:["..cell2.x..":"..cell2.y.."]:".."vis"..tostring(visible))     return visibleendfunction Map:isCellVisibleFrom(cell1, cell2)        return self:getVisibility(cell1, cell2)endreturn Map